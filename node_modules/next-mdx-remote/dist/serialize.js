'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var mdx = require('@mdx-js/mdx');
var esbuild = require('esbuild');
var path = require('path');
var pkgDir = require('pkg-dir');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var mdx__default = /*#__PURE__*/_interopDefaultLegacy(mdx);
var path__default = /*#__PURE__*/_interopDefaultLegacy(path);
var pkgDir__default = /*#__PURE__*/_interopDefaultLegacy(pkgDir);

/**
 * @typedef {import('unist').Node} Node
 * @typedef {import('unist').Parent} Parent
 *
 * @typedef {string} Type
 * @typedef {Object<string, unknown>} Props
 */

var convert =
  /**
   * @type {(
   *   (<T extends Node>(test: T['type']|Partial<T>|TestFunctionPredicate<T>) => AssertPredicate<T>) &
   *   ((test?: null|undefined|Type|Props|TestFunctionAnything|Array.<Type|Props|TestFunctionAnything>) => AssertAnything)
   * )}
   */
  (
    /**
     * Generate an assertion from a check.
     * @param {null|undefined|Type|Props|TestFunctionAnything|Array.<Type|Props|TestFunctionAnything>} [test]
     * When nullish, checks if `node` is a `Node`.
     * When `string`, works like passing `function (node) {return node.type === test}`.
     * When `function` checks if function passed the node is true.
     * When `object`, checks that all keys in test are in node, and that they have (strictly) equal values.
     * When `array`, checks any one of the subtests pass.
     * @returns {AssertAnything}
     */
    function (test) {
      if (test === undefined || test === null) {
        return ok
      }

      if (typeof test === 'string') {
        return typeFactory(test)
      }

      if (typeof test === 'object') {
        // @ts-ignore looks like a list of tests / partial test object.
        return 'length' in test ? anyFactory(test) : propsFactory(test)
      }

      if (typeof test === 'function') {
        return castFactory(test)
      }

      throw new Error('Expected function, string, or object as test')
    }
  );
/**
 * @param {Array.<Type|Props|TestFunctionAnything>} tests
 * @returns {AssertAnything}
 */
function anyFactory(tests) {
  /** @type {Array.<AssertAnything>} */
  var checks = [];
  var index = -1;

  while (++index < tests.length) {
    checks[index] = convert(tests[index]);
  }

  return castFactory(any)

  /**
   * @this {unknown}
   * @param {unknown[]} parameters
   * @returns {boolean}
   */
  function any(...parameters) {
    var index = -1;

    while (++index < checks.length) {
      if (checks[index].call(this, ...parameters)) return true
    }
  }
}

/**
 * Utility to assert each property in `test` is represented in `node`, and each
 * values are strictly equal.
 *
 * @param {Props} check
 * @returns {AssertAnything}
 */
function propsFactory(check) {
  return castFactory(all)

  /**
   * @param {Node} node
   * @returns {boolean}
   */
  function all(node) {
    /** @type {string} */
    var key;

    for (key in check) {
      if (node[key] !== check[key]) return
    }

    return true
  }
}

/**
 * Utility to convert a string into a function which checks a given node’s type
 * for said string.
 *
 * @param {Type} check
 * @returns {AssertAnything}
 */
function typeFactory(check) {
  return castFactory(type)

  /**
   * @param {Node} node
   */
  function type(node) {
    return node && node.type === check
  }
}

/**
 * Utility to convert a string into a function which checks a given node’s type
 * for said string.
 * @param {TestFunctionAnything} check
 * @returns {AssertAnything}
 */
function castFactory(check) {
  return assertion

  /**
   * @this {unknown}
   * @param {Array.<unknown>} parameters
   * @returns {boolean}
   */
  function assertion(...parameters) {
    return Boolean(check.call(this, ...parameters))
  }
}

// Utility to return true.
function ok() {
  return true
}

/**
 * @typedef {import('unist').Node} Node
 * @typedef {import('unist').Parent} Parent
 *
 * @typedef {import('unist-util-is').Type} Type
 * @typedef {import('unist-util-is').Props} Props
 * @typedef {import('unist-util-is').TestFunctionAnything} TestFunctionAnything
 */

/** @type {Array.<Node>} */
var empty = [];

var remove =
  /**
   * @type {(
   *  (<T extends Node>(node: T, options: RemoveOptions, test: Type|Props|TestFunctionAnything|Array<Type|Props|TestFunctionAnything>) => T|null) &
   *  (<T extends Node>(node: T, test: Type|Props|TestFunctionAnything|Array<Type|Props|TestFunctionAnything>) => T|null)
   * )}
   */
  (
    /**
     * Mutate the given tree by removing all nodes that pass `test`.
     * The tree is walked in preorder (NLR), visiting the node itself, then its head, etc.
     *
     * @param {Node} tree Tree to filter
     * @param {RemoveOptions} options Whether to drop parent nodes if they had children, but all their children were filtered out. Default is `{cascade: true}`
     * @param {Type|Props|TestFunctionAnything|Array<Type|Props|TestFunctionAnything>} test is-compatible test (such as a type)
     * @returns {Node|null}
     */
    function (tree, options, test) {
      var is = convert(test || options);
      var cascade =
        options.cascade === undefined || options.cascade === null
          ? true
          : options.cascade;

      return preorder(tree, null, null)

      /**
       * Check and remove nodes recursively in preorder.
       * For each composite node, modify its children array in-place.
       *
       * @param {Node} node
       * @param {number|null} index
       * @param {Parent|null} parent
       * @returns {Node|null}
       */
      function preorder(node, index, parent) {
        /** @type {Array.<Node>} */
        // @ts-ignore looks like a parent.
        var children = node.children || empty;
        var childIndex = -1;
        var position = 0;

        if (is(node, index, parent)) {
          return null
        }

        if (children.length > 0) {
          // Move all living children to the beginning of the children array.
          while (++childIndex < children.length) {
            // @ts-ignore looks like a parent.
            if (preorder(children[childIndex], childIndex, node)) {
              children[position++] = children[childIndex];
            }
          }

          // Cascade delete.
          if (cascade && !position) {
            return null
          }

          // Drop other nodes.
          children.length = position;
        }

        return node
      }
    }
  );

/**
 * Ensure we use node's native require.resolve method,
 * webpack overrides require.resolve by default and returns the module ID
 * instead of the resolved path
 */
const requireResolve = 
// @ts-expect-error -- check if we're in a webpack context
typeof __non_webpack_require__ === 'function'
    ? // @ts-expect-error -- __non_webpack_require__ === require at this point
        __non_webpack_require__.resolve
    : require.resolve;
/**
 * Due to the way Next.js is built and deployed, esbuild's internal use of
 * __dirname to derive the path to its binary does not work. This function
 * gets around that by explicitly setting the path based on the CWD.
 *
 * Related: https://nextjs.org/docs/basic-features/data-fetching#reading-files-use-processcwd
 */
function setEsbuildBinaryPath() {
    const esbuildDir = pkgDir__default['default'].sync(requireResolve('esbuild'));
    if (!esbuildDir)
        throw new Error('[next-mdx-remote] unable to determine path to esbuild, try setting process.env.ESBUILD_BINARY_PATH manually.');
    // c.f.: https://www.arcath.net/2021/03/mdx-bundler#esbuild-executable
    if (process.platform === 'win32') {
        process.env.ESBUILD_BINARY_PATH = path__default['default'].join(esbuildDir, 'esbuild.exe');
    }
    else {
        process.env.ESBUILD_BINARY_PATH = path__default['default'].join(esbuildDir, 'bin', 'esbuild');
    }
}
setEsbuildBinaryPath();
/**
 * remark plugin which removes all import and export statements
 */
const removeImportsExportsPlugin = () => (tree) => remove(tree, ['import', 'export']);
/**
 * Parses and compiles the provided MDX string. Returns a result which can be passed into <MDXRemote /> to be rendered.
 */
async function serialize(
/** Raw MDX contents as a string. */
source, { scope = {}, mdxOptions = {}, target = ['es2020', 'node12'], } = {}) {
    // don't modify the original object when adding our own plugin
    // this allows code to reuse the same options object
    const remarkPlugins = [
        ...(mdxOptions.remarkPlugins || []),
        removeImportsExportsPlugin,
    ];
    mdxOptions = {
        ...mdxOptions,
        remarkPlugins,
    };
    const compiledMdx = await mdx__default['default'](source, { ...mdxOptions, skipExport: true });
    const transformResult = await esbuild.transform(compiledMdx, {
        loader: 'jsx',
        jsxFactory: 'mdx',
        minify: true,
        target,
    });
    return {
        compiledSource: transformResult.code,
        scope,
    };
}

exports.serialize = serialize;
